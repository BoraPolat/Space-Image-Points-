<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Yaren Animasyonu</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      margin: 0;
      background-color: #000;
    }
    body {
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -webkit-text-size-adjust: none;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }
    canvas {
      display: block;
    }
    #fullscreenBtn {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px 15px;
      background-color: rgba(255, 255, 255, 0.2);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.5);
      border-radius: 8px;
      font-family: sans-serif;
      font-size: 14px;
      cursor: pointer;
      z-index: 1000;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      transition: background-color 0.3s ease;
    }
    #fullscreenBtn:hover {
      background-color: rgba(255, 255, 255, 0.4);
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
</head>
<body>
  <button id="fullscreenBtn">Tam Ekran</button>
  <script>
    let stars = [];
    let spinningStars = [];
    let holdTime = 0;
    let spinning = false;
    let explosionTriggered = false;
    const transitionTime = 2000;

    let realStars = [];
    let fadeStars = [];
    let fadeTimer = 0;
    let centerStar = null;
    let bgFade = 0;

    let starsToSpin = [];
    let spinTimer = 0;

    let secondExplosionTriggered = false;
    let thirdExplosionTriggered = false;
    let affectedStars = [];
    let waveRadius = 0;
    let waveVisible = false;
    let realStarsCreatedTime = 0;

    let allPoints = [];

    let isMouseActive = false;
    let isTouchActive = false;
    
    // Sabit bir en-boy oranı için sanal koordinatlar oluşturur.
    const VIRTUAL_WIDTH = 1600;
    const VIRTUAL_HEIGHT = 1000;

    // Yıldızları ve hedef noktalarını oluşturan fonksiyon
    function createStars(p) {
      stars = [];
      allPoints = [];

      let starColors = [
        p.color(255, 255, 255),
        p.color(200, 220, 255),
        p.color(180, 180, 255),
        p.color(255, 255, 255),
        p.color(200, 220, 255),
        p.color(180, 180, 255)
      ];

      for (let i = 0; i < 400; i++) {
        stars.push({
          x: p.random(p.width),
          y: p.random(p.height),
          size: p.random(1, 3),
          alpha: p.random(100, 255),
          baseSpeedX: p.random(-0.2, 0.2),
          baseSpeedY: p.random(-0.2, 0.2),
          inertiaX: 0,
          inertiaY: 0,
          inertiaCounter: 0,
          color: p.random(starColors)
        });
      }

      // Yıldızlar için hedef noktalarını sanal tuval üzerinde oluşturma
      for (let i = 0; i < 5000; i++) {
        allPoints.push({
          x: p.random(VIRTUAL_WIDTH),
          y: p.random(VIRTUAL_HEIGHT)
        });
      }
    }

    // Ana eskiz fonksiyonu
    let sketch = function(p) {
      p.setup = function() {
        p.createCanvas(p.windowWidth, p.windowHeight);
        createStars(p);
        p.noStroke();

        p.mousePressed = function() { isMouseActive = true; }
        p.mouseReleased = function() { isMouseActive = false; }
        p.touchStarted = function() { isTouchActive = true; return false; }
        p.touchEnded = function() { isTouchActive = false; return false; }
        
        // Pencere boyutu değiştiğinde tuvali yeniden boyutlandır ve yıldızları yeniden oluştur
        p.windowResized = function() { 
          p.resizeCanvas(p.windowWidth, p.windowHeight); 
          createStars(p);
        }
      }

      p.draw = function() {
        p.background(0);

        if (explosionTriggered) {
          if (bgFade < 255) bgFade += 0.2;
          p.fill(0, bgFade);
          p.rect(0, 0, p.width, p.height);
        }

        let tx = p.mouseX;
        let ty = p.mouseY;
        let isPressed = isMouseActive || p.touches.length > 0;

        if (p.touches.length > 0) {
          tx = p.touches[0].x;
          ty = p.touches[0].y;
        }

        if (isPressed) {
          holdTime += p.deltaTime / 1000;
        } else {
          holdTime = 0;
        }

        for (let star of stars) {
          if (star === centerStar) {
            p.fill(255);
            p.ellipse(star.x, star.y, star.size * 2);
            continue;
          }

          if (isPressed) {
            let d = p.dist(tx, ty, star.x, star.y);
            if (d < 250 && !spinning) {
              let angle = p.atan2(ty - star.y, tx - star.x);
              let pull = 0.5;
              star.inertiaX = p.cos(angle) * pull;
              star.inertiaY = p.sin(angle) * pull;
              star.inertiaCounter = 30;
            } else {
              if (star.inertiaCounter > 0) star.inertiaCounter--;
              else {
                star.inertiaX *= 0.95;
                star.inertiaY *= 0.95;
              }
            }
          }

          star.x += star.baseSpeedX + star.inertiaX;
          star.y += star.baseSpeedY + star.inertiaY;

          if (star.x < 0) star.x = p.width;
          if (star.x > p.width) star.x = 0;
          if (star.y < 0) star.y = p.height;
          if (star.y > p.height) star.y = 0;
          
          if (spinning && spinningStars.length > 0) {
            let closest = null;
            let minDist = 9999;
            let strongestStar = null;

            for (let s of spinningStars) {
              let cx = s.x + p.cos(s.angle) * s.radius + s.offsetX;
              let cy = s.y + p.sin(s.angle) * s.radius + s.offsetY;
              let distTo = p.dist(star.x, star.y, cx, cy);
              if (distTo < minDist) {
                minDist = distTo;
                closest = { x: cx, y: cy };
                strongestStar = s;
              }
            }

            if (closest && minDist < 200) {
              let angle = p.atan2(closest.y - star.y, closest.x - star.x);
              let basePull = p.map(minDist, 0, 200, 0.5, 0.02);
              let pull = basePull * strongestStar.speedMultiplier;
              star.inertiaX = p.cos(angle) * pull;
              star.inertiaY = p.sin(angle) * pull;
              star.inertiaCounter = 30;
            }
          }

          p.fill(p.red(star.color), p.green(star.color), p.blue(star.color), star.alpha);
          p.ellipse(star.x, star.y, star.size);
        }

        if (holdTime >= 5 && !spinning) {
          spinning = true;
          starsToSpin = stars.sort(() => 0.5 - p.random()).slice(0, 200);
          centerStar = starsToSpin[0];
          centerStar.size = 2;
        }

        if (spinning && starsToSpin.length > 0) {
          spinTimer += p.deltaTime / 1000;
          if (spinTimer >= 0.05) {
            let star = starsToSpin.shift();
            spinningStars.push({
              x: star.x,
              y: star.y,
              size: star.size,
              alpha: star.alpha,
              color: star.color,
              angle: p.random(p.TWO_PI),
              radius: p.random(80, 120),
              baseSpeed: 0.02,
              speedMultiplier: 0,
              acceleration: 0.001,
              maxMultiplier: 2.0,
              offsetX: p.random(-20, 20),
              offsetY: p.random(-20, 20),
              targetX: p.width / 2,
              targetY: p.height / 2,
              vx: 0,
              vy: 0
            });
            spinTimer = 0;
          }
        }

        if (spinning) {
          for (let s of spinningStars) {
            s.x += (s.targetX - s.x) * 0.003;
            s.y += (s.targetY - s.y) * 0.003;

            if (!explosionTriggered) s.speedMultiplier += s.acceleration;

            s.angle += s.baseSpeed * s.speedMultiplier;
            let cx = s.x + p.cos(s.angle) * s.radius + s.offsetX;
            let cy = s.y + p.sin(s.angle) * s.radius + s.offsetY;

            p.fill(p.red(s.color), p.green(s.color), p.blue(s.color), s.alpha);
            p.ellipse(cx, cy, s.size);

            if (s.speedMultiplier >= s.maxMultiplier && !explosionTriggered) {
              explosionTriggered = true;
              for (let ex of spinningStars) {
                let angle = p.random(p.TWO_PI);
                let force = p.random(5, 15);
                ex.vx = p.cos(angle) * force;
                ex.vy = p.sin(angle) * force;
              }

              fadeStars = stars.filter(st => st !== centerStar).map(st => ({ ...st, fading: false, fadeAlpha: st.alpha }));
            }

            if (explosionTriggered) {
              s.x += s.vx;
              s.y += s.vy;
              s.alpha *= 0.9;
            }
          }
        }

        if (fadeStars.length > 0 && explosionTriggered) {
          let totalTime = 12;
          let starsPerFrame = fadeStars.length / (totalTime * 60);

          for (let i = fadeStars.length - 1; i >= 0; i--) {
            let st = fadeStars[i];

            st.fadeAlpha -= 255 / (totalTime * 60);
            if (st.fadeAlpha < 0) st.fadeAlpha = 0;

            if (st.fadeAlpha <= 0) {
              fadeStars.splice(i, 1);
              stars.splice(stars.indexOf(st), 1);
            } else {
              p.fill(p.red(st.color), p.green(st.color), p.blue(st.color), st.fadeAlpha);
              p.ellipse(st.x, st.y, st.size);
            }
          }
        }

        if (centerStar) {
          centerStar.x += (p.width / 2 - centerStar.x) * 0.0015;
          centerStar.y += (p.height / 2 - centerStar.y) * 0.0015;

          if (!centerStar.particles) centerStar.particles = [];
          if (!centerStar.explosionDone) centerStar.explosionDone = false;
          if (!centerStar.waitStart) centerStar.waitStart = false;

          if (explosionTriggered && fadeStars.length === 0) {
            if (!centerStar.startTime) centerStar.startTime = p.millis();

            let elapsed = (p.millis() - centerStar.startTime) / 1000;
            let baseSize = centerStar.size * 1.5;
            let currentSize = baseSize;
            let alpha = 255;

            if (elapsed < 3) {
              currentSize = baseSize;
            } else if (elapsed >= 3 && elapsed < 5) {
              let t = (elapsed - 3) / 2.0;
              currentSize = p.lerp(baseSize, baseSize * 3, t);
            } else if (elapsed >= 5 && elapsed < 15) {
              currentSize = baseSize * 3;
              let t = (elapsed - 5);
              let cycle = p.floor(t / 2);
              if (cycle < 5) {
                let phase = (t % 2) / 2;
                alpha = p.lerp(255, 128, p.sin(phase * p.PI));
              } else {
                alpha = 255;
                if (!centerStar.waitStart) centerStar.waitStart = p.millis();
              }
            } else if (!centerStar.explosionDone) {
              let waitElapsed = (p.millis() - centerStar.waitStart) / 1000;
              if (!centerStar.waitStart) centerStar.waitStart = p.millis();

              if (waitElapsed >= 2) {
                if (centerStar.particles.length === 0) {
                  for (let i = 0; i < 400; i++) {
                    let angle = p.random(p.TWO_PI);
                    let speed = p.random(3, 16);
                    centerStar.particles.push({
                      x: centerStar.x,
                      y: centerStar.y,
                      vx: p.cos(angle) * speed,
                      vy: p.sin(angle) * speed,
                      size: p.random(2, 5),
                      alpha: 255
                    });
                  }
                  for (let i = 0; i < 5000; i++) {
                    let angle = p.random(p.TWO_PI);
                    let speed = p.random(3, 16);
                    realStars.push({
                      x: centerStar.x,
                      y: centerStar.y,
                      vx: p.cos(angle) * speed,
                      vy: p.sin(angle) * speed,
                      size: p.random(2, 5),
                      targetIndex: i,
                      brightness: 255,
                      moveStartTime: 0,
                      movingToTarget: false
                    });
                  }
                  realStarsCreatedTime = p.millis();
                }

                currentSize = centerStar.size * 3;
                p.fill(255, 200, 150, 180);
                p.ellipse(centerStar.x, centerStar.y, currentSize * 1.2);

                for (let i = 0; i < centerStar.particles.length; i++) {
                  let p_particle = centerStar.particles[i];
                  p_particle.vx *= 0.95;
                  p_particle.vy *= 0.95;
                  p_particle.vx += p.random(-0.1, 0.1);
                  p_particle.vy += p.random(-0.1, 0.1);
                  p_particle.x += p_particle.vx;
                  p_particle.y += p_particle.vy;
                  p_particle.alpha -= 4;
                  p.fill(255, p_particle.alpha);
                  p.ellipse(p_particle.x, p_particle.y, p_particle.size);
                }

                centerStar.explosionDone = true;
              }
            }

            p.fill(255, alpha);
            p.ellipse(centerStar.x, centerStar.y, currentSize);
          } else {
            p.fill(255);
            p.ellipse(centerStar.x, centerStar.y, centerStar.size * 2);
          }
        }

        if (centerStar && centerStar.explosionDone && realStarsCreatedTime > 0) {
          const elapsedSinceRealStars = p.millis() - realStarsCreatedTime;
          
          // Ölçekleme faktörünü mevcut tuvalin boyutuna göre hesaplama
          let currentAspect = p.width / p.height;
          let scale;
          let offsetX = 0;
          let offsetY = 0;
          const targetAspect = VIRTUAL_WIDTH / VIRTUAL_HEIGHT;

          if (currentAspect > targetAspect) {
            // Ekran daha genişse, yüksekliğe göre ölçekle
            scale = p.height / VIRTUAL_HEIGHT;
            offsetX = (p.width - VIRTUAL_WIDTH * scale) / 2;
          } else {
            // Ekran daha uzunsa, genişliğe göre ölçekle
            scale = p.width / VIRTUAL_WIDTH;
            offsetY = (p.height - VIRTUAL_HEIGHT * scale) / 2;
          }

          for (let i = 0; i < realStars.length; i++) {
            let s = realStars[i];

            if (elapsedSinceRealStars < 10000) {
              s.vx *= 0.98;
              s.vy *= 0.98;
              s.vx += p.random(-0.05, 0.05);
              s.vy += p.random(-0.05, 0.05);
            } else {
              if (!s.movingToTarget) {
                s.movingToTarget = true;
                s.moveStartTime = p.millis();
              }
              
              // Hedef koordinatları ölçekle ve ortala
              const targetX = allPoints[s.targetIndex].x * scale + offsetX;
              const targetY = allPoints[s.targetIndex].y * scale + offsetY;

              const dx = targetX - s.x;
              const dy = targetY - s.y;
              const distance = p.sqrt(dx * dx + dy * dy);

              if (distance > 50) {
                let timeSinceStart = p.millis() - s.moveStartTime;
                let accelerationFactor = p.map(timeSinceStart, 0, 8000, 0.005, 1.0);
                accelerationFactor = p.constrain(accelerationFactor, 0.005, 1.0);
                
                const baseSpeed = 0.05;
                const speed = baseSpeed * accelerationFactor;
                s.vx = (dx / distance) * speed * distance * 0.1;
                s.vy = (dy / distance) * speed * distance * 0.1;
              } else {
                s.vx = 0;
                s.vy = 0;
                s.x = targetX;
                s.y = targetY;
              }
            }

            s.x += s.vx;
            s.y += s.vy;

            p.fill(255, s.brightness);
            p.ellipse(s.x, s.y, s.size);
          }
        }
      }
    };
    
    new p5(sketch);

    // Tam ekran düğmesini bulma ve tıklama olayı ekleme
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    
    // Tam ekran mantığını yöneten fonksiyon
    const toggleFullscreen = () => {
      // Daha güvenilir bir tam ekran isteği için html öğesini kullanın
      const element = document.documentElement;
      if (!document.fullscreenElement) {
        // Daha iyi uyumluluk için tarayıcıya özgü önekleri kullanın
        if (element.requestFullscreen) {
          element.requestFullscreen();
        } else if (element.webkitRequestFullscreen) { /* Safari & Chrome */
          element.webkitRequestFullscreen();
        } else if (element.msRequestFullscreen) { /* IE11 */
          element.msRequestFullscreen();
        } else if (element.mozRequestFullScreen) { /* Firefox */
          element.mozRequestFullScreen();
        }
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari & Chrome */
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
          document.msExitFullscreen();
        } else if (document.mozCancelFullScreen) { /* Firefox */
          document.mozCancelFullScreen();
        }
      }
    };
    
    if (fullscreenBtn) {
      // Mobil uyumluluk için hem tıklama hem de dokunma başlangıcı olay dinleyicileri ekleyin
      fullscreenBtn.addEventListener('click', toggleFullscreen);
      fullscreenBtn.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Tam ekran fonksiyonunun tetiklendiğinden emin olmak için varsayılan dokunma davranışını engelle
        toggleFullscreen();
      });
    }
  </script>
</body>
</html>
