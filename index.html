<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Yarosum</title>
  <style>
    body {
      touch-action: manipulation;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -webkit-text-size-adjust: none;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
      overflow: hidden;
      margin: 0;
      background-color: #000;
      /* body'nin ve canvas'ın tam ekran olmasını sağlamak için */
      width: 100vw;
      height: 100vh;
      display: flex; /* İçeriği ortalamak için */
      justify-content: center;
      align-items: center;
    }
    canvas {
      display: block;
      touch-action: none;
      user-select: none;
      /* Canvas'ın viewport'u doldurmasını sağla */
      max-width: 100vw;
      max-height: 100vh;
      object-fit: contain; /* Görüntü oranını koru */
    }
    #fullscreen-btn {
        position: fixed; /* absolute yerine fixed, viewport'a göre sabit kalır */
        top: 20px;
        left: 20px;
        background-color: rgba(255, 255, 255, 0.3); /* Biraz daha şeffaf */
        color: white;
        border: none;
        padding: 12px 18px; /* Daha büyük ve okunur */
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Modern font */
        font-size: 16px; /* Daha büyük font */
        cursor: pointer;
        border-radius: 8px; /* Daha yumuşak köşeler */
        z-index: 1000;
        backdrop-filter: blur(5px); /* Hafif blur efekti */
        -webkit-backdrop-filter: blur(5px); /* Safari desteği */
        transition: background-color 0.3s ease; /* Hover efekti için */
    }
    #fullscreen-btn:hover {
        background-color: rgba(255, 255, 255, 0.5); /* Hover'da daha belirgin */
    }
 </style>
</head>
<body>
 <button id="fullscreen-btn" onclick="goFullscreen()">Tam Ekran</button>
 <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
 <script>
    function goFullscreen() {
        const docEl = document.documentElement;
        
        // Standart tam ekran API'leri (PC ve Android için)
        if (docEl.requestFullscreen) {
            docEl.requestFullscreen();
        } else if (docEl.mozRequestFullScreen) { /* Firefox */
            docEl.mozRequestFullScreen();
        } else if (docEl.webkitRequestFullscreen) { /* Chrome, Safari ve Opera */
            docEl.webkitRequestFullscreen();
        } else if (docEl.msRequestFullscreen) { /* IE/Edge */
            docEl.msRequestFullscreen();
        }

        // iOS Safari için özel tam ekran modu
        // Bu yöntem, tarayıcı UI'ını gizleyerek tam ekran benzeri bir deneyim sunar
        // "Add to Home Screen" özelliği ile daha iyi sonuç verir, ancak doğrudan tarayıcıda da çalışır
        if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
            const btn = document.getElementById('fullscreen-btn');
            btn.style.display = 'none'; // Butonu gizle

            // Safari'de adres çubuğunu ve alt çubuğu gizlemek için
            const hideSafariUI = () => {
                // Ekran yüksekliğinden 1 piksel fazla yaparak tarayıcıyı kaydırmaya zorlar
                if (document.body.scrollHeight < window.innerHeight) {
                    document.body.style.height = (window.innerHeight + 1) + 'px';
                }
                setTimeout(() => {
                    window.scrollTo(0, 1);
                }, 100);
            };
            
            hideSafariUI();
            // Ekran boyutu değiştiğinde veya yön değiştirildiğinde tekrar uygula
            window.addEventListener('resize', hideSafariUI);
            window.addEventListener('orientationchange', hideSafariUI);
        }
    }
    
    // Kullanıcı tarafından sağlanan JavaScript kodu
    let stars = [];
    let spinningStars = [];
    let holdTime = 0;
    let spinning = false;
    let explosionTriggered = false;
    let explosionStartTime = 0;
    const transitionTime = 2000; // 2 saniye (milisaniye cinsinden)

    let realStars = [];
    let fadeStars = [];
    let fadeTimer = 0;
    let centerStar = null;
    let bgFade = 0; // arkaplan kararma için

    let starsToSpin = []; // seçilecek yıldızların sıraya alınacağı dizi
    let spinTimer = 0; // 0.05 saniyede bir yıldız eklemek için

    // Yeni değişkenler
    let secondExplosionTriggered = false;
    let thirdExplosionTriggered = false;
    let secondExplosionStartTime = 0;
    let thirdExplosionStartTime = 0;
    let affectedStars = []; // ikinci patlamadan etkilenen yıldızlar
    let waveRadius = 0; // güç dalgası yarıçapı
    let waveVisible = false;
    let realStarsCreatedTime = 0; // realStars oluşturulduğu zaman
    // Yeni eklenen değişkenler
    let isMouseActive = false;
    let isTouchActive = false;

    // allPoints ve handPoints tanımları eksik, bu yüzden burada varsayılan boş diziler oluşturuyorum.
    // Lütfen bu dizileri kendi istediğiniz noktalarla doldurun.
    // Eğer bunlar olmadan kullanırsanız, realStars hedeflerine gidemez.
    const allPoints = []; 
    for (let i = 0; i < 5000; i++) {
        allPoints.push({ x: random(), y: random() });
    }
    const handPointsRaw = [];
    for (let i = 0; i < 500; i++) {
        handPointsRaw.push({ x: random(), y: random() });
    }


    // Ekran oranı düzeltmesi için değişkenler
    let virtualHeight; // 16:10 oranında hesaplanacak sanal yükseklik
    let offsetY; // Görselı ortalamak için Y ekseni kaydırması

    // Cihazın yan çevrilmesini sağlamak için eklenen kod
    function lockScreenOrientation() {
      if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock("landscape-primary").catch(function(error) {
          console.error("Ekran yönü kilitlenemedi: " + error);
        });
      }
    }

    // Dokunma olaylarının varsayılan davranışlarını engelle
    function preventDefault(event) {
      event.preventDefault();
      event.stopPropagation();
    }
    window.addEventListener('touchstart', preventDefault, { passive: false });
    window.addEventListener('touchend', preventDefault, { passive: false });
    window.addEventListener('touchmove', preventDefault, { passive: false });

    function setup() {
      createCanvas(windowWidth, windowHeight);
      lockScreenOrientation();
      
      // 16:10 oranı için sanal yükseklik hesapla
      calculateVirtualDimensions();
      
      window.addEventListener('resize', () => {
        resizeCanvas(windowWidth, windowHeight);
        calculateVirtualDimensions();
      });

      // Yıldız renkleri (gerçek yıldız renklerine yakın)
      let starColors = [
        color(255, 255, 255), // beyaz
        color(200, 220, 255), // mavi-beyaz
        color(180, 180, 255), // sarı
        color(255, 255, 255), // turuncu
        color(200, 220, 255), // kırmızımsı
        color(180, 180, 255) // açık mavi
      ];

      for (let i = 0; i < 400; i++) {
        stars.push({
          x: random(width),
          y: random(height),
          size: random(1, 3),
          alpha: random(100, 255),
          baseSpeedX: random(-0.2, 0.2),
          baseSpeedY: random(-0.2, 0.2),
          inertiaX: 0,
          inertiaY: 0,
          inertiaCounter: 0,
          color: random(starColors)
        });
      }

      noStroke();
    }

    // 16:10 oranı için sanal boyutları hesapla
    function calculateVirtualDimensions() {
      // Ekran genişliğini al, 16:10 oranında yükseklik hesapla
      virtualHeight = width * (10 / 16);
      
      // Eğer hesaplanan yükseklik gerçek yükseklikten küçükse, görselı ortala
      if (virtualHeight <= height) {
        offsetY = (height - virtualHeight) / 2;
      } else {
        // Eğer sanal yükseklik gerçek yükseklikten büyükse, genişliği ayarla
        let virtualWidth = height * (16 / 10);
        virtualHeight = height;
        offsetY = 0;
      }
    }

    // Koordinat dönüştürme fonksiyonu
    function getVirtualCoordinates(normalizedX, normalizedY) {
      return {
        x: normalizedX * width,
        y: normalizedY * virtualHeight + offsetY
      };
    }
    
    // Olay dinleyicileri
    function mousePressed() {
      isMouseActive = true;
    }

    function mouseReleased() {
      isMouseActive = false;
    }

    function touchStarted() {
      isTouchActive = true;
      return false; // varsayılan davranışı engelle
    }

    function touchEnded() {
      isTouchActive = false;
      return false; // varsayılan davranışı engelle
    }


    function draw() {
      // Arka plan normalde siyah, patlamadan sonra kademeli kararma
      background(0);
      if (explosionTriggered) {
        if (bgFade < 255) bgFade += 0.2;
        fill(0, bgFade);
        rect(0, 0, width, height);
      }

      let tx = mouseX;
      let ty = mouseY;
      let isPressed = isMouseActive || isTouchActive; // Yeni değişkenlerle kontrol

      if (touches.length > 0) {
        tx = touches[0].x;
        ty = touches[0].y;
      }

      // Sadece basılı tutuluyorsa holdTime artar, yoksa sıfırlanır
      if (isPressed) {
        holdTime += deltaTime / 1000;
      } else {
        holdTime = 0;
      }

      // Normal yıldızlar
      for (let star of stars) {
        // centerStar etkilenmesin
        if (star === centerStar) {
          fill(255);
          ellipse(star.x, star.y, star.size * 2);
          continue;
        }

        // Yalnızca basılı tutuluyorsa interaksiyon başlar
        if (isPressed) {
          let d = dist(tx, ty, star.x, star.y);
          if (d < 250 && !spinning) {
            let angle = atan2(ty - star.y, tx - star.x);
            let pull = 0.5;
            star.inertiaX = cos(angle) * pull;
            star.inertiaY = sin(angle) * pull;
            star.inertiaCounter = 30;
          } else {
            if (star.inertiaCounter > 0) star.inertiaCounter--;
            else {
              star.inertiaX *= 0.95;
              star.inertiaY *= 0.95;
            }
          }
        }

        star.x += star.baseSpeedX + star.inertiaX;
        star.y += star.baseSpeedY + star.inertiaY;

        if (star.x < 0) star.x = width;
        if (star.x > width) star.x = 0;
        if (star.y < 0) star.y = height;
        if (star.y > height) star.y = 0;
        
        if (spinning && spinningStars.length > 0) {
          let closest = null;
          let minDist = 9999;
          let strongestStar = null;

          for (let s of spinningStars) {
            let cx = s.x + cos(s.angle) * s.radius + s.offsetX;
            let cy = s.y + sin(s.angle) * s.radius + s.offsetY;
            let distTo = dist(star.x, star.y, cx, cy);
            if (distTo < minDist) {
              minDist = distTo;
              closest = { x: cx, y: cy };
              strongestStar = s;
            }
          }

          if (closest && minDist < 200) {
            let angle = atan2(closest.y - star.y, closest.x - star.x);
            let basePull = map(minDist, 0, 200, 1.0, 0.04);
            let pull = basePull * strongestStar.speedMultiplier;
            star.inertiaX = cos(angle) * pull;
            star.inertiaY = sin(angle) * pull;
            star.inertiaCounter = 30;
          }
        }

        fill(red(star.color), green(star.color), blue(star.color), star.alpha);
        ellipse(star.x, star.y, star.size);
      }

      // 5 saniye basılı ise spinning başlatacak yıldızları sıraya al
      if (holdTime >= 5 && !spinning) {
        spinning = true;
        starsToSpin = stars.sort(() => 0.5 - random()).slice(0, 200);
        centerStar = starsToSpin[0]; // özel yıldız
        centerStar.size = 2; // orta boyut olarak sabitlendi
      }

      // Sıradaki yıldızları 0.05 saniyede bir spinningStars dizisine ekle
      if (spinning && starsToSpin.length > 0) {
        spinTimer += deltaTime / 1000;
        if (spinTimer >= 0.05) {
          let star = starsToSpin.shift();
          spinningStars.push({
            x: star.x,
            y: star.y,
            size: star.size,
            alpha: star.alpha,
            color: star.color,
            angle: random(TWO_PI),
            radius: random(80, 120),
            baseSpeed: 0.04,
            speedMultiplier: 0,
            acceleration: 0.002,
            maxMultiplier: 1.70,
            offsetX: random(-20, 20),
            offsetY: random(-20, 20),
            targetX: width / 2,
            targetY: height / 2,
            vx: 0,
            vy: 0
          });
          spinTimer = 0;
        }
      }

      // Dönen yıldızlar ve patlama
      if (spinning) {
        for (let s of spinningStars) {
          s.x += (s.targetX - s.x) * 0.015;
          s.y += (s.targetY - s.y) * 0.015;

          if (!explosionTriggered) s.speedMultiplier += s.acceleration;

          s.angle += s.baseSpeed * s.speedMultiplier;
          let cx = s.x + cos(s.angle) * s.radius + s.offsetX;
          let cy = s.y + sin(s.angle) * s.radius + s.offsetY;

          fill(red(s.color), green(s.color), blue(s.color), s.alpha);
          ellipse(cx, cy, s.size);

          if (s.speedMultiplier >= s.maxMultiplier && !explosionTriggered) {
            explosionTriggered = true;
            for (let ex of spinningStars) {
              let angle = random(TWO_PI);
              let force = random(5, 10);
              ex.vx = cos(angle) * force;
              ex.vy = sin(angle) * force;
            }

            fadeStars = stars.filter(st => st !== centerStar).map(st => ({ ...st, fading: false, fadeAlpha: st.alpha }));
          }

          if (explosionTriggered) {
            s.x += s.vx;
            s.y += s.vy;
            s.alpha *= 0.85;
          }
        }
      }

      // Fade efekti (sıra sıra, 12 saniyede tüm yıldızlar)
      if (fadeStars.length > 0 && explosionTriggered) {
        let totalTime = 5; // saniye cinsinden toplam süre
        let starsPerFrame = fadeStars.length / (totalTime * 60); // 60 fps varsayımıyla

        for (let i = fadeStars.length - 1; i >= 0; i--) {
          let st = fadeStars[i];

          // Her karede sadece starsPerFrame kadar alpha düşürüyoruz
          st.fadeAlpha -= 255 / (totalTime * 60);
          if (st.fadeAlpha < 0) st.fadeAlpha = 0;

          if (st.fadeAlpha <= 0) {
            fadeStars.splice(i, 1);
            stars.splice(stars.indexOf(st), 1);
          } else {
            fill(red(st.color), green(st.color), blue(st.color), st.fadeAlpha);
            ellipse(st.x, st.y, st.size);
          }
        }
      }

      if (centerStar) {
        // centerStar ekran ortasına ilerliyor
        centerStar.x += (width / 2 - centerStar.x) * 0.0015;
        centerStar.y += (height / 2 - centerStar.y) * 0.0015;

        if (!centerStar.particles) centerStar.particles = [];
        if (!centerStar.explosionDone) centerStar.explosionDone = false;
        if (!centerStar.waitStart) centerStar.waitStart = false;

        // Tüm fadeStars bittiğinde efekt başlasın
        if (explosionTriggered && fadeStars.length === 0) {
          if (!centerStar.startTime) centerStar.startTime = millis();

          let elapsed = (millis() - centerStar.startTime) / 1000;
          let baseSize = centerStar.size * 1.5;
          let currentSize = baseSize;
          let alpha = 255;

          if (elapsed < 3) {
            currentSize = baseSize;
          } else if (elapsed >= 3 && elapsed < 5) {
            let t = (elapsed - 3) / 2.0;
            currentSize = lerp(baseSize, baseSize * 3, t);
          } else if (elapsed >= 5 && elapsed < 15) {
            currentSize = baseSize * 3;
            let t = (elapsed - 5);
            let cycle = floor(t / 2);
            if (cycle < 5) {
              let phase = (t % 2) / 2;
              alpha = lerp(255, 128, sin(phase * PI));
            } else {
              alpha = 255;
              if (!centerStar.waitStart) centerStar.waitStart = millis();
            }
          } else if (!centerStar.explosionDone) {
            let waitElapsed = (millis() - centerStar.waitStart) / 1000;
            if (!centerStar.waitStart) centerStar.waitStart = millis();

            if (waitElapsed >= 2) {
              //  Patlama ve gerçek yıldızları oluştur
              if (centerStar.particles.length === 0) {
                for (let i = 0; i < 400; i++) { // daha fazla parçacık
                  let angle = random(TWO_PI);
                  let speed = random(3, 16); // hız aralığını genişlettik
                  centerStar.particles.push({
                    x: centerStar.x,
                    y: centerStar.y,
                    vx: cos(angle) * speed,
                    vy: sin(angle) * speed,
                    size: random(2, 5),
                    alpha: 255
                  });
                }
                for (let i = 0; i < 5000; i++) { // gerçek yıldızları da ekleyelim
                  let angle = random(TWO_PI);
                  let speed = random(3, 16);
                  realStars.push({
                    x: centerStar.x,
                    y: centerStar.y,
                    vx: cos(angle) * speed,
                    vy: sin(angle) * speed,
                    size: random(2, 5),
                    targetIndex: i, // allPoints'teki index
                    brightness: 255, // parlaklık kontrolü
                    moveStartTime: 0, // hedefe gitmeye başlama zamanı
                    movingToTarget: false
                  });
                }
                realStarsCreatedTime = millis(); // RealStars oluşturulma zamanını kaydet
              }

              // centerStar patlama anında parlayan bir halo gibi büyüsün
              currentSize = centerStar.size * 3;
              fill(255, 200, 150, 180); // hafif turuncu-sarı glow
              ellipse(centerStar.x, centerStar.y, currentSize * 1.2);

              // Patlama parçacıklarını hareket ettir
              for (let i = 0; i < centerStar.particles.length; i++) {
                let p = centerStar.particles[i];
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.vx += random(-0.1, 0.1);
                p.vy += random(-0.1, 0.1);
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 4; // yavaş yavaş kaybolsun
                fill(255, p.alpha);
                ellipse(p.x, p.y, p.size);
              }

              centerStar.explosionDone = true;
            }
          }

          // Patlama sonrası centerStar
          fill(255, alpha);
          ellipse(centerStar.x, centerStar.y, currentSize);
        } else {
          fill(255);
          ellipse(centerStar.x, centerStar.y, centerStar.size * 2);
        }
      }

      // Gerçek yıldızları çiz ve hareket ettir
      if (centerStar && centerStar.explosionDone && realStarsCreatedTime > 0) {
        const elapsedSinceRealStars = millis() - realStarsCreatedTime;
        
        // RealStars hareket mantığı
        for (let i = 0; i < realStars.length; i++) {
          let s = realStars[i];

          if (elapsedSinceRealStars < 10000) {
            // İlk 10 saniye: Serbest hareket
            s.vx *= 0.98;
            s.vy *= 0.98;
            s.vx += random(-0.05, 0.05);
            s.vy += random(-0.05, 0.05);
          } else {
            // 10 saniye sonra: Hedefe gitmeye başla
            if (!s.movingToTarget) {
              s.movingToTarget = true;
              s.moveStartTime = millis();
            }
            
            // ÖNEMLİ DEĞİŞİKLİK: Koordinat dönüştürme burada yapılıyor
            // allPoints dizisindeki koordinatlar 0-1 arasında normalized olmalı
            // Örnek: allPoints[0] = {x: 0.5, y: 0.3} gibi
            const virtualCoords = getVirtualCoordinates(
              allPoints[s.targetIndex].x, 
              allPoints[s.targetIndex].y
            );
            const targetX = virtualCoords.x;
            const targetY = virtualCoords.y;

            const dx = targetX - s.x;
            const dy = targetY - s.y;
            const distance = sqrt(dx * dx + dy * dy);

            if (distance > 50) { // Hedefe yakın değilse
              // Zamanla hızlanma - başlangıçta çok yavaş, sonra hızlanır
              let timeSinceStart = millis() - s.moveStartTime;
              let accelerationFactor = map(timeSinceStart, 0, 8000, 0.005, 1.0); // 8 saniyede tam hıza çıkar
              accelerationFactor = constrain(accelerationFactor, 0.005, 1.0);
              
              const baseSpeed = 0.05;
              const speed = baseSpeed * accelerationFactor;
              s.vx = (dx / distance) * speed * distance * 0.1;
              s.vy = (dy / distance) * speed * distance * 0.1;
            } else {
              // Hedefe çok yakınsa dur
              s.vx = 0;
              s.vy = 0;
              s.x = targetX;
              s.y = targetY;
            }
          }

          // Konumu güncelle
          s.x += s.vx;
          s.y += s.vy;

          fill(255, s.brightness);
          ellipse(s.x, s.y, s.size);
        }
      }
    }
  </script>
</body>
</html>
